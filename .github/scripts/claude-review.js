const Anthropic = require('@anthropic-ai/sdk');
const { Octokit } = require('@octokit/rest');
const { execSync } = require('child_process');

// Configuration
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

const octokit = new Octokit({
  auth: process.env.GITHUB_TOKEN,
});

const PR_NUMBER = process.env.PR_NUMBER;
const REPO_OWNER = process.env.REPO_OWNER;
const REPO_NAME = process.env.REPO_NAME;

// Review configuration for Go projects
const REVIEW_CONFIG = {
  maxFilesPerReview: 10,
  maxCharsPerFile: 8000,
  focusAreas: [
    'Security vulnerabilities and best practices',
    'Performance optimizations',
    'Code maintainability and readability',
    'Go idioms and conventions',
    'Error handling patterns',
    'Testing coverage and quality',
    'Documentation completeness',
    'API design consistency',
    'Memory safety and resource management',
    'Concurrency safety'
  ],
  excludePatterns: [
    'go.sum',
    '*.generated.go',
    'vendor/',
    '.git/'
  ]
};

async function getDiffContent() {
  try {
    console.log('Fetching PR diff...');
    const { data: pullRequest } = await octokit.rest.pulls.get({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      pull_number: PR_NUMBER,
    });

    const { data: files } = await octokit.rest.pulls.listFiles({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      pull_number: PR_NUMBER,
    });

    return {
      pullRequest,
      files: files.filter(file => 
        !REVIEW_CONFIG.excludePatterns.some(pattern => 
          file.filename.includes(pattern)
        )
      ).slice(0, REVIEW_CONFIG.maxFilesPerReview)
    };
  } catch (error) {
    console.error('Error fetching diff:', error);
    throw error;
  }
}

async function analyzeWithClaude(diffData) {
  const { pullRequest, files } = diffData;
  
  // Prepare the context for Claude
  const fileChanges = files.map(file => ({
    filename: file.filename,
    status: file.status,
    additions: file.additions,
    deletions: file.deletions,
    patch: file.patch ? file.patch.substring(0, REVIEW_CONFIG.maxCharsPerFile) : null
  }));

  const prompt = `
You are an expert Go developer conducting a thorough code review for a JWT claims demo project. 

**Project Context:**
- Repository: ${REPO_OWNER}/${REPO_NAME}
- PR Title: ${pullRequest.title}
- PR Description: ${pullRequest.body || 'No description provided'}
- This is a Go microservice using Gin framework with JWT authentication

**Focus Areas for Review:**
${REVIEW_CONFIG.focusAreas.map(area => `- ${area}`).join('\n')}

**Files Changed:**
${fileChanges.map(file => `
File: ${file.filename} (${file.status})
+${file.additions} -${file.deletions}
${file.patch ? '\nDiff:\n```diff\n' + file.patch + '\n```' : 'No patch available'}
`).join('\n---\n')}

**Instructions:**
1. Review each file change carefully
2. Identify potential issues, improvements, and best practices
3. Focus on Go-specific patterns and JWT security considerations
4. Provide specific, actionable feedback
5. Highlight any security concerns with JWT handling
6. Check for proper error handling and testing

**Response Format:**
Please provide your review in the following format:

## üìã Code Review Summary

### ‚úÖ Positive Aspects
- List what's done well

### ‚ö†Ô∏è Issues Found
- **[Severity: High/Medium/Low]** Issue description
  - File: \`filename\`
  - Line: (if applicable)
  - Suggestion: Specific recommendation

### üîí Security Considerations
- Any security-related observations

### üöÄ Performance & Best Practices
- Performance optimization suggestions
- Go idiom improvements

### üìù Documentation & Testing
- Documentation improvements needed
- Testing recommendations

### üéØ Overall Recommendation
- [ ] Approve (ready to merge)
- [ ] Request changes (specific issues must be addressed)
- [ ] Comment (suggestions for improvement)

Provide specific, actionable feedback that helps improve code quality.
`;

  try {
    console.log('Sending request to Claude...');
    const response = await anthropic.messages.create({
      model: 'claude-3-5-sonnet-20241022',
      max_tokens: 4000,
      temperature: 0.1,
      messages: [{
        role: 'user',
        content: prompt
      }]
    });

    return response.content[0].text;
  } catch (error) {
    console.error('Error calling Claude API:', error);
    throw error;
  }
}

async function postReviewComment(reviewContent) {
  try {
    console.log('Posting review comment...');
    
    const commentBody = `## ü§ñ AI Code Review by Claude

${reviewContent}

---
*This review was automatically generated by Claude AI. Please use this as a supplement to human code review.*`;

    await octokit.rest.issues.createComment({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      issue_number: PR_NUMBER,
      body: commentBody
    });

    console.log('Review comment posted successfully!');
  } catch (error) {
    console.error('Error posting comment:', error);
    throw error;
  }
}

async function main() {
  try {
    console.log(`Starting AI code review for PR #${PR_NUMBER}`);
    
    // Validate required environment variables
    if (!process.env.ANTHROPIC_API_KEY) {
      throw new Error('ANTHROPIC_API_KEY environment variable is required');
    }
    if (!process.env.GITHUB_TOKEN) {
      throw new Error('GITHUB_TOKEN environment variable is required');
    }

    // Get diff content
    const diffData = await getDiffContent();
    
    if (diffData.files.length === 0) {
      console.log('No reviewable files found in this PR');
      return;
    }

    console.log(`Reviewing ${diffData.files.length} files...`);
    
    // Analyze with Claude
    const review = await analyzeWithClaude(diffData);
    
    // Post the review
    await postReviewComment(review);
    
    console.log('Code review completed successfully!');
    
  } catch (error) {
    console.error('Code review failed:', error);
    process.exit(1);
  }
}

// Run the main function
main();
